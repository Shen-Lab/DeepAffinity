from __future__ import division
import re
import sys
import getopt
exposedCut = 0.3   #threshold for classify as exposed
# ssInputDir = r'uniqueProtein.fasta-out.ss'
# accInputDir = r'uniqueProtein.fasta-out.acc'
# group_output = r'grouped_output'
polarDic = {'G':'G','A':'G','L':'G','V':'G','I':'G','M':'G','F':'G','W':'G','P':'G','S':'T','T':'T','C':'T','Y':'T','N':'T','Q':'T','D':'D','E':'D','K':'K','R':'K','H':'K'}
# dic = {'He': 'A', 'H-': 'B', 'Ce': 'C', 'C-': 'D', 'Ee': 'E', 'E-': 'F'}

def main(opts):
    for op, value in opts:
        if op == "-a":
            accInputDir = value                  #Corresponding ACC file
        elif op == "-s":
            ssInputDir = value                   #Corresponding Secondary Structure file
        elif op == "-p":
            uniqueProteinDir = value             # All unique protein from target file
        else:
            print("Wrong options. Options can only contain '-a', '-s', '-p'")
            sys.exit()
    # accInputDir = 'uniqueProtein.fasta-out.acc'
    # ssInputDir = 'uniqueProtein.fasta-out.ss'
    # uniqueProteinDir = 'uniqueProtein.sdf'       # All unique protein from target file
    group_output = 'protein_grouped_finalPresentation'    #Generated by Output_Seperatly.py
    groupTwo(accInputDir, ssInputDir, uniqueProteinDir, group_output)

def proteinPolar(seq):
    #G: nonpolar T: polar D: acidic K: basic
    seqDic = {'G':0, 'T':0, 'D':0, 'K':0}
    meanDic = {'G':0.505, 'T':0.253, 'D':0.111, 'K':0.131}
    total = 0
    for i in seq:
        if i in polarDic:
            total += 1
            seqDic[polarDic[i]] += 1
    for i in seqDic:
        seqDic[i] = seqDic[i]/total/meanDic[i]
#     seqList = sorted(seqDic.items(), key=lambda x:x[1], reverse = True)
    return max(seqDic.items(), key=lambda x: x[1])[0]

def localSmoothForSS(string):
    cNum = string.count('C')
    hNum = string.count('H')
    eNum = string.count('E')
    length = len(string)
    if cNum > eNum:
        maxNum = cNum
        maxL = 'C'
    else:
        maxL = 'E'
        maxNum = eNum
    if maxNum <= hNum:
        maxL = 'H'
    return maxL * length


# smooth for Secondary Structure
def smoothForSS(line):
    consecNum = 4  # number of consecutive letters
    maxNumLetter = 7  # number of max settling letters
    descRe = r'>.*'
    consecCount = 0  # number of consective letters
    maxNumCount = 0  # number of letters
    twiceChangeM = 0  # twice changes mark, if the string changes at the end of string twice,
                      # we will not allow more chages any more. e.g. 'EEECCCECECC', we only take maxNumLetter = 7
                      # letters, EEECCCE
    twiceChangeCon = 0  # twice change continue mark
    # descLine = ''
    finStr = ''
    tempStr = ''
    lastTempStr = ''  # store string without the latest letter
    if not re.match(descRe, line):
        mark1 = line[0]
        for c in line:
            maxNumCount += 1
            tempStr += c
            if twiceChangeM == 0:
                if c == mark1:
                    consecCount += 1
                    lastTempStr += c
                elif consecCount >= 3 and mark1 == 'C':
                    lastTempStr = len(lastTempStr) * mark1
                    finStr += lastTempStr
                    lastTempStr = tempStr[-1]
                    tempStr = tempStr[-1]
                    consecCount = 1
                    maxNumCount = 1
                    mark1 = tempStr[-1]
                elif consecCount > consecNum:
                    lastTempStr = len(lastTempStr) * mark1
                    finStr += lastTempStr
                    lastTempStr = tempStr[-1]
                    tempStr = tempStr[-1]
                    consecCount = 1
                    maxNumCount = 1
                    mark1 = tempStr[-1]
                elif maxNumCount > maxNumLetter:
                    cNum = lastTempStr.count('C')
                    hNum = lastTempStr.count('H')
                    eNum = lastTempStr.count('E')
                    s = (len(lastTempStr) + 1) / 2
                    if cNum > s:
                        lastTempStr = len(lastTempStr) * 'C'
                    elif hNum > s:
                        lastTempStr = len(lastTempStr) * 'H'
                    elif eNum > s:
                        lastTempStr = len(lastTempStr) * 'E'
                    else:
                        twiceChangeM = 1
                        mark1 = c
                    if twiceChangeM == 0:
                        finStr += lastTempStr
                        lastTempStr = tempStr[-1]
                        tempStr = tempStr[-1]
                        consecCount = 1
                        maxNumCount = 1
                        mark1 = tempStr[-1]
                else:
                    mark1 = c
                    lastTempStr += c
                    consecCount = 1
            else:
                if c == mark1:
                    if twiceChangeCon == 0:
                        lastTempStr += (tempStr[-2] + tempStr[-1])
                        twiceChangeCon = 1
                    else:
                        lastTempStr += c
                else:
                    if twiceChangeCon == 1:
                        lastTempStr = localSmoothForSS(lastTempStr)
                        finStr += lastTempStr
                        lastTempStr = tempStr[-1]
                        tempStr = tempStr[-1]
                        consecCount = 1
                        maxNumCount = 1
                        mark1 = c
                        twiceChangeM = 0
                        twiceChangeCon = 0
                    else:
                        lastTempStr = localSmoothForSS(lastTempStr)
                        finStr += lastTempStr
                        lastTempStr = (tempStr[-2] + tempStr[-1])
                        tempStr = tempStr[-2] + tempStr[-1]
                        consecCount = 1
                        maxNumCount = 2
                        mark1 = c
                        twiceChangeM = 0
                        twiceChangeCon = 0
        if lastTempStr != '\n':
            lastTempStr = lastTempStr.strip()
            if len(lastTempStr) > maxNumLetter:
                lastTempStr = localSmoothForSS(lastTempStr)
            elif lastTempStr.count('C') > ((maxNumLetter + 1) / 2) and lastTempStr.count('C') > (
                len(lastTempStr) / 2):
                lastTempStr = len(lastTempStr) * 'C'
            elif lastTempStr.count('E') > ((maxNumLetter + 1) / 2) and lastTempStr.count('E') > (
                len(lastTempStr) / 2):
                lastTempStr = len(lastTempStr) * 'E'
            elif lastTempStr.count('H') > ((maxNumLetter + 1) / 2) and lastTempStr.count('H') > (
                len(lastTempStr) / 2):
                lastTempStr = len(lastTempStr) * 'H'
            else:
                if len(finStr) != 0:
                    lastTempStr = len(lastTempStr) * finStr[-1]
                else:
                    lastTempStr = line.strip()
                    print(line)
                    #continue
                    #maxCount = lastTempStr.count('C')
                    #maxChar = 'C'
                    #if lastTempStr.count('E')
            finStr += lastTempStr
    return finStr


def merge(acc, ss, protein):
    global dic
    global exposedCut
    acc= acc.replace('\n', '')
    ss = smoothForSS(ss).replace('\n', '')
    result = ''
    i = 0
    countE = 0
    count = 0
    mark = ss[0]  # mark for acc 'HEC'
    storeProtein = ''
    while i < len(ss):
        if mark == ss[i]:
            storeProtein += protein[i]
            count += 1
            if acc[i] == 'e':
                countE += 1
        else:
            #transfer mark for SS to representation form
            if mark == 'H':
                ssMark = 'A'
            elif mark == 'E':
                ssMark = 'B'
            else:
                ssMark = 'C'

            if countE/count >= exposedCut:
                groupM = ssMark+'E'
            else:
                groupM = ssMark + 'N'

            groupM += proteinPolar(storeProtein)

            if count <= 7:
                groupM += 'S'
            elif count <= 15:
                groupM += 'M'
            else:
                groupM += 'L'
            # result += dic[groupM] + str(count)    #Mark
            mark = ss[i]
            storeProtein = protein[i]
            count = 1
            if acc[i] == 'e':
                countE = 1
            else:
                countE = 0
            result += groupM + ','

        i += 1
        if i == len(acc):
            if mark == 'H':
                ssMark = 'A'
            elif mark == 'E':
                ssMark = 'B'
            else:
                ssMark = 'C'
                
            if countE/count >= exposedCut:
                groupM = ssMark + 'E'
            else:
                groupM = ssMark + 'N'

            groupM += proteinPolar(storeProtein)

            if count <= 7:
                groupM += 'S'
            elif count <= 15:
                groupM += 'M'
            else:
                groupM += 'L'
            result += groupM
            return result


def groupTwo(accInputDir, ssInputDir, uniqueProteinDir, group_output):
    # max = 0
    reName = r'>.+'
    w = open(group_output, 'w+')
    tempStr = ''
    nextL = ''
    with open(accInputDir) as f1, open(ssInputDir) as f2, open(uniqueProteinDir) as f3:
        for acc in f1:
            ss = f2.readline()
            if re.match(reName, acc):
                if nextL == '':
                    protein = f3.readline()
                else:
                    protein = nextL
                if acc == ss and protein == acc:
                    continue
                else:
                    print('Error, Three files have different sequence names')
                    return 'Error'
            else:
                protein = ''
                nextL = f3.readline()
                while not re.match(reName, nextL) and nextL != '':
                    protein += nextL.strip()
                    nextL = f3.readline()
                result = merge(acc, ss, protein)
                # if len(result) > max and len(result) != 277:
                #     max = len(result)
                w.write(protein.strip()+'\n')
                w.write(result + '\n')
    print('%s : Group Success!'%uniqueProteinDir)
    # print max



if __name__ == '__main__':
    if len(sys.argv) != 7:
        print("usage: group.py -a <acc file> -s <secondary structure file> -p <protein sequence file>")
        sys.exit()
    opts, args = getopt.getopt(sys.argv[1:], "a:s:p:")
    main(opts)
